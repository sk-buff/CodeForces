# solution to 1537E1

这个题并不是很难，但是一开始没过是因为16行的条件写的是l < n而不是l < k，17和20行也没有写l % n，这样写在n >= k的时候是没有问题的，但是在n < k的时候有问题，用语言解释比较麻烦，直接给出一个例子，对于以下输入

```
7 9
cabcabc
```

如果写l < n的话得到的结果是cabcabcca，最后的ca是cabcabc和自己拼接后得到的，但实际上正确结果是cabcabcab，方式是：

```
cabcabc => cabcab => cabcabcabcab => cabcabcab
```

也就是说，当k > n时，如果在原始字符串的某个位置出现了该位置的字符与原始字符串第一个字符相同的字符的情况的时候，且从该位置开始到最后一个字符的这一个子串与从原始字符串的头开始的一样长的子串完全一样的时候，写l < n的话就没有考虑把字符串删除到这个字符前一个字符的位置然后再double的可能性，这种情况可能比不删除任何字符直接double（上例中的错误结果）要好。而在出现上述情况的时候，最终结果一定是直接double（因为从该位置到原始字符串最后一个元素中间必然不存在比该元素/字符串头元素要大的元素）。

其实还有一种写法，就是把长度为n的原始数组转化为长度为k的数组，转化的方法也很简单，n > k时截断，n < k时把自己复制x份并拼接在一起，保证xn > k然后截断到k长度即可
